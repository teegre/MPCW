#! /usr/bin/env bash

###################################
# a wrapper+ for mpc              #
#  _ __ ___  _ __   _____      __ #
# | '_ ` _ \| '_ \ / __\ \ /\ / / #
# | | | | | | |_) | (__ \ V  V /  #
# |_| |_| |_| .__/ \___| \_/\_/   #
#           |_| version 0.1       #
###################################

# ALIASES

alias add="mpc add"
alias new="stop; mpc clear; mpc add"
alias list="mpc ls"
alias ins="mpc insert"
alias del="mpc -q del"
alias clr="mpc -q clear"
alias cr="mpc -q crop"
alias sta="mpc -q single" # stop after current
alias rn="mpc -q random"
alias cs="mpc -q consume"
alias rnd="getrnd"
alias nx="next"
alias pv="prev"
alias mns="musicnonstop"
alias mnsa="musicnonstop album"
alias mnss="musicnonstop song"
alias mnso="musicnonstop off"
alias move="mpc -q move"
alias xf="mpc crossfade"
alias xfo="mpc crossfade 0"
alias rpg="mpc replaygain"
alias rpga="mpc replaygain album"
alias rpgt="mpc replaygain track"
alias rpgo="mpc replaygain auto"
alias p="toggle"
alias pl="play"
alias pla="play_album"
alias aa="add_album"
alias nxa="next_album"
alias s="stop"
alias sk="skip"
alias usk="unskip"
alias skl="set_skip_limit"
alias seeal="see_album"
alias seear="see_artist"
alias seek="mpc -q seek"
alias upd="((mpc -q update --wait && notify-send 'mpcw: update finished') &)"

# VARIABLES

MPCW_CONFIG=~/.config/mpcw/config
MPCW_HIST=~/.config/mpcw/hist
MPCW_LOG=~/.config/mpcw/mpcw.log
TMPSIMA=~/.config/mpcw/artists.tmp
TMPWAV=~/.config/mpcw/saytmp.wav
SIMA=~/.config/mpcw/artists
STICKER_DB=~/.config/mpd/sticker.sql
PID=~/.config/mpcw/mpcw.pid
WPID=~/.config/mpcw/mpcw.wpid
MPCW_LOCK=~/.config/mpcw/lock
MPCW_NTF='
%artist%
%title%
%album%
[%date%]'
MPCW_FMT='artist %artist%\ntitle %title%\nalbum %album%\ndate %date%'

#

logme() {
    echo "$(now) --- $*" >> $MPCW_LOG
}

read_config() {
    # read config file.
    # create it if it doesn't exist.
    if [ -s "$MPCW_CONFIG" ]; then
      case "$1" in
          "volume") awk 'NR==1 {print $2}' "$MPCW_CONFIG" ;;
	  "nonstop") awk 'NR==2 {print $2}' "$MPCW_CONFIG" ;;
	  "filter") awk -v OFS=" " 'NR==3 {for (i=2; i<=NF; i++) printf("%s ", $i)}' "$MPCW_CONFIG" ;;
	  "clean") awk -v OFS=" " 'NR==4 {for (i=2; i<=NF; i++) printf("%s ", $i)}' "$MPCW_CONFIG" ;;
	  "skip") awk 'NR==5 {print $2}' "$MPCW_CONFIG" ;;
	  "voice") awk 'NR==6 {print $2}' "$MPCW_CONFIG" ;;
	  *) return 1
      esac
    else
	local settings
	settings="volume 100
nonstop off
filter off
clean_every 1 month
skip 2
voice on
"
	mkdir ~/.config/mpcw 2>/dev/null
        echo "$settings" > $MPCW_CONFIG
    fi
}

write_config() {
    # write current config to file.
    local settings
    settings="volume $VOLUME
nonstop $NONSTOP
filter $NONSTOP_FILTER
clean_every $CLEAN_FREQ
skip_limit $SKIP_LIMIT
voice $VOICE
"
    echo "$settings" > $MPCW_CONFIG
}

media_update() {
        {
	    echo "status" "$(pstatus)"
            mpc current -f "$MPCW_FMT"
        } > ~/.config/currentmedia

        kill -1 "$(pidof -x "pmt")" 2>/dev/null
}

do_loop() {
    # main loop.
    # triggered each time a player event occurs.
    # it takes care of displaying notifications,
    # and handles playlist.
    while read -r; do

	S="$(pstatus)"
	icon="$(pstatus icon)"

	media_update

        if [[ "$(status single)" == "on" ]]; then
	    mpc -q single off
	elif ! [[ -a "$MPCW_LOCK" ]]; then
	    handle_playlist
	fi

        NONSTOP=$(read_config nonstop)

	if [[ "$S" != "[stopped]" ]]; then
	    (($(playcount)))
	    notify-send -u low "$icon x$playcount $(mpc current -f "$MPCW_NTF") $(rating s)"
	    local n=$((RANDOM%10))
	    [[ $n == 5 ]] && sleep 5 && __say
	elif [[ "$NONSTOP" == "off" ]]; then
	    notify-send -u low "$icon"
	fi

    done < <(mpc idleloop player 2>/dev/null)
}

startd() {
    # start mpcw as a daemon.
    # if we have a pid file
    [[ -a $PID ]] && {
	# check if there is an active process with this id
	    local pid
	    pid="$(cat "$PID")"
	    # if so, we do nothing
	    [[ "$(ps --no-headers --pid "$pid")" ]] && return
	}
    # otherwise, we start the daemon
    rm $PID 2>/dev/null
    rm $WPID 2>/dev/null
    __clean
    do_loop & 
    disown
    echo $! > "$PID"
    __watch &
    disown
    echo $! > "$WPID"
    [[ "$(pstatus)" != "[stopped]" ]] && 
	media_update
	    clear
	    echo "[>> mpcw daemon has started."
	}

# Stop daemon.
stopd() {
    if [[ -a $PID ]]; then
	local pid
	local ppid
	local wpid
	local wppid
	pid="$(cat "$PID")"
	wpid="$(cat "$WPID")"
	rm "$PID"
	rm "$WPID"
	ppid="$(ps --no-headers --ppid "$pid" | awk '{print $1}')"
	wppid="$(ps --no-headers --ppid "$wpid" | awk '{print $1}')"
	kill "$ppid" 2>/dev/null
	kill "$wppid" 2>/dev/null
	kill "$pid" 2>/dev/null
	sleep 1
	echo  > ~/.config/currentmedia
	kill -1 "$(pidof -x "pmt")" 2>/dev/null
	echo "[|] mpcw daemon has stopped."
    else
	echo "[X] mpcw daemon is not running."
    fi
}

__watch() {
    # playback statistics updater
    local song
    local duration
    local elapsed
    logme "DAEMON: started."
    while :; do
	if ! [[ -a $PID ]]; then
	    logme "DAEMON: stopped."
	    return 0
	fi
	if [[ "$(pstatus)" == "[playing]" ]]; then
	    song="$(getinfo file)"
	    duration="$(echo 'status\n' | nc localhost 6600 | awk '$1~"duration" {print $2}')"
	    duration=${duration//.*}
	    ((duration-=1))
	    elapsed="$(echo 'status\n' | nc localhost 6600 | awk '$1~"elapsed" {print $2}')"
	    elapsed=${elapsed//.*}
	    if [[ "$elapsed" == "$duration"  && -n "$song" ]]; then
		update_stats "$song"
		echo "$(now) --- $song" >> $MPCW_HIST
		mpc idle player >/dev/null
	    else
                sleep 0.125
            fi
	else
	    __clean
            mpc idle player >/dev/null
	fi
    done
}

__say() {
    # say current artist and title.
    [[ $(pstatus) != "[playing]" ]] && return 1
    local radio
    case "$(read_config nonstop)" in
	"song") radio="MUSIC NON STOP RADIO";;
	"sima") radio="SIMA RADIO";;
    esac
    [[ -n "$radio" ]] && {
	(! type espeak >/dev/null) || {
	    local msg
	    msg="...You are listening to: $(getinfo artist), $(getinfo title)... On $radio."
	    espeak -v en+f4 -w $TMPWAV -s 140 2>/dev/null <<< echo "$msg"
	    mpc -q volume -30
	    mpv --no-terminal $TMPWAV
	    mpc -q volume +30
	    rm $TMPWAV
	}
    }
}

__clean() {
    local freq
    freq="$(read_config clean)"
    local date
    date=$(date -d "now -$freq" "+%Y-%m-%d")
    cp $MPCW_HIST $MPCW_HIST.backup
    sed -i "/^$date/d" $MPCW_HIST
    if [[ -n $(diff "$MPCW_HIST" "$MPCW_HIST.backup") ]]; then
	 logme "cleaned history."
    fi

}

clean_freq() {
    # TODO: check user input
    if [ "$*" ]; then
	CLEAN_FREQ="$1"
	write_config
    else
	echo "mpcw: no argument."
	echo "usage: clean_freq <num [day(s)|week(s)|month(s)|year(s)>"
    fi
}

toggle() {
    case "$(pstatus)" in
        "[paused]") __fadein;;
        "[playing]") __fadeout;;
        *) play
   esac
}

play() {
    echo > $MPCW_LOCK
    local volume
    volume="$(read_config volume)"
    NONSTOP="$(read_config nonstop)"
    if [[ "$(pstatus)" == "[paused]" ]]; then
        __fadein
    elif [[ "$(pstatus)" == "[stopped]" ]] && [[ $NONSTOP != "off" ]]; then
        if ! handle_playlist; then
            mpc -q --wait play "$@"
	    sleep 0.0625
            mpc -q volume "$volume"
	fi
    else
	mpc -q random off
	mpc -q crossfade 0
        mpc -q --wait play "$@"
	sleep 0.0625
        mpc -q volume "$volume"
    fi
    rm $MPCW_LOCK 2>/dev/null
}

play_album() {
    # play current song's album
    # if first track of the said album is playing, don't stop
    if [[ $(pstatus) == "[playing]" ]]; then
        album="$(getinfo file)"
        album="${album%/*}"
	[[ "$(mpc ls "$album" | wc -l)" == 1 ]] && return
        mpc -q random off
        mpc -q crossfade 0
	mpc -q replaygain album
        if [[ "$(getinfo track)" == 1 ]]; then
            mpc -q crop
            mpc add "$album"
            mpc -q del 2
        else
            mpc -q clear
	    mpc -q add "$album"
	    mpc -q play 1
        fi
	mpc -q replaygain album
	VOICE="off"; write_config
	echo "mpcw: now playing album: $(mpc current -f "%artist% - %album%")"
    else
        echo "mpcw: not playing."
    fi
}

next() {
    if [[ "$(pstatus)" == "[paused]" ]]; then
	mpc -q --wait next
	mpc -q pause
	__fadein
    else
	mpc -q next
    fi
}

prev() {
    if [[ "$(pstatus)" == "[paused}" ]]; then
	mpc -q --wait prev
	mpc -q pause
	__fadein
    else
	mpc -q prev
    fi
}

add_album() {
    # add current song's album.
    if [[ $(pstatus) == "[playing]" ]]; then
	album="$(getinfo file)"
	album="${album%/*}"
	[[ "$(mpc ls "$album" | wc -l)" == 1 ]] && return
	mpc -q random off
	mpc -q crossfade 0
	mpc -q replaygain album
	mpc -q crop
	mpc -q add "$album"
	[[ "$(getinfo track)" == 1 ]] && mpc -q del 2
	echo "mpcw: added album: $(mpc current -f "%artist% - %album%")"
	VOICE="off"; write_config
    fi
}

see_album() {
    # display current song's album.
    if [[ $(pstatus) != "[stopped]" ]]; then
        album="$(getinfo file)"
	album="${album%/*}"
	mpc ls "$album"
   fi
}

see_artist() {
    # display current artist's albums.
    if [[ $(pstatus) != "[stopped]" ]]; then
        artist="$(getinfo file)"
	artist="${artist%%/*}"
	mpc ls "$artist"
    fi
}

pause() {
    if [[ $(pstatus) == "[paused]" ]]; then
        toggle
    else
        __fadeout "pause"
    fi
}

next_album() {
    if [[ $(pstatus) == "[playing]" ]] &&
      [[ $(read_config nonstop) == "album" ]]; then
	clr
    else
	echo "mpcw: not in album mode!"
    fi
}

__is_in_history() {
    grep -q "$1" "$MPCW_HIST" 2>/dev/null
    echo $?
}

__is_in_playlist() {
    mpc playlist -f "%file%" > "current"
    grep -q "$1" "current" 2>/dev/null
    echo $?
    rm "current" 2>/dev/null
}

search() {
    if [ "$*" ]; then
        command="mpc search"
        for ARG in "$@"; do
            command="$command any $ARG"
        done
	eval "$command"
    fi
}

search_tag() {
    if [ "$*" ]; then
        if ! ( mpc search "$@" 2>/dev/null ); then
	    error=1
	else
	    error=0
	fi
    else
	error=1
    fi
    [[ "$error" -eq 1 ]] &&
    (
	echo "mpcw: <$*> did not return any result!"
	echo "usage: search_tag <tag value ... tag value>"
	return 1
    )
}

find_tag() {
    if [ "$*" ]; then
	if ! (mpc find "$@" 2>/dev/null); then
	    error=1
	else
	    error=0
	fi
    else
	error=1
    fi
    [[ "$error" -eq 1 ]] && {
	echo "mpcw: <$*> did not return any result!"
	echo "usage: search_tag <tag value ... tag value>"
	return 1
    }
}
   
__search() {
    echo "select uri from sticker where name=\"$1\" and value $2 $3;"
    sqlite3 "$STICKER_DB" "select uri from sticker where name=\"$1\" and value $2 $3;"
}

skipcount() {
    local skipcount
    skipcount=$(mpc sticker "$(getinfo file)" get "skipcount" 2>/dev/null)
    echo "${skipcount:-"skipcount=0"}"
}

playcount() {
    local playcount
    local song
    song="$(mpc current -f "%artist% - %title%" | tr '[:upper:]' '[:lower:]')"
    playcount="$(mpc sticker "$(getinfo file)" get "playcount" 2>/dev/null)"
    echo "${playcount:-playcount=0}"
}

lastplayed() {
    lastplayed=$(mpc sticker "$(getinfo file)" get "lastplayed" 2>/dev/null)
    [[ -n $lastplayed ]] && echo "$lastplayed"
}

skip() {
    local skipcount
    (($(skipcount)))
    ((skipcount+=1))
    mpc sticker "$1" set "lastplayed" "$(now)" 2>/dev/null
    mpc sticker "$(getinfo file)" set "skipcount" "$skipcount" 2>/dev/null
    next
}

unskip() {
    mpc sticker "$1" set "skipcount" 0 2>/dev/null
}

set_skip_limit() {
    if [[ $1 =~ ^[0-9]+$ ]]; then
	SKIP_LIMIT=$1; write_config
    else
	echo "mpcw: skip_limit=$(read_config skip)"
    fi
}

stop() {
    if [[ "$(pstatus)" == "[playing]" ]]; then
      __fadeout "stop"
    else
      mpc -q stop
    fi
}

vol() {
    if [ -z "$1" ]; then
      read_config volume
    elif [[ "$(pstatus)" != "[stopped]" ]]; then
      mpc -q volume "$1"
      VOLUME="$(status volume)"
      write_config
    else
      VOLUME="$1"
      write_config
    fi
}

dim() {
    # -6dB dimmer.
    [[ $(pstatus) == "[stopped]" || $(pstatus) == "[paused]" ]] &&
	{
	    echo "mpcw: not playing"
    	    return
	}
    local current_volume
    local saved_volume
    current_volume="$(status volume)"
    saved_volume="$(read_config volume)"
    if [[ $current_volume -lt $saved_volume ]]; then
	mpc -q volume "$saved_volume"
	echo "mpcw: dim off"
    elif [[ $current_volume -eq $saved_volume ]]; then
	((current_volume/=2))
	mpc -q volume $current_volume
	echo "mpcw: dim on"
   fi
}

getinfo() {
    if [ "$1" ]; then
	local info
	info=$(mpc current -f "%$1%")
	[[ "$info" == "%*" ]] && return 1
	echo "$info"
    else
	return 1
    fi
}

getnext() {
    local command
    command=$(mpc queued -f "%$1%")
    [[ $command == "%"* ]] || echo "$command"
}

getrnd() {
    # get random songs / albums
    if [[ $1 =~ ^[0-9]+$ ]]; then
        local count
	count=$1
	shift
        case "$1" in
            "album")
                if [[ "$2" == "off" ]] || [[ -z "$2" ]]; then
                    mpc listall 2>/dev/null | shuf -n "$count" | sed 's/\/[0-9]+*.*//'
		else
		    shift
		    search_tag "$@" | shuf -n "$count" | sed 's/\/[0-9]+*.*//'
		fi
	        ;;
	    "song")
		if [[ "$2" == "off" ]] || [[ -z "$2" ]]; then
		    i=0
		    while [ $i -lt "$count" ]; do
			while read -r line; do
			    (($(mpc sticker "$line" get "skipcount" 2>/dev/null)))
			    skc=${skipcount:-0}
			    skl=$(read_config "skip")
			    [[ $skc -gt $skl ]] && continue
			    [[ $(__is_in_history "$line") == 0 ||
				$(__is_in_playlist "$line") == 0 ]] ||
			    { 
				echo "$line"
				((i++))
			    }
			done <<< "$(mpc listall | shuf -n 1)"
		    done
		else
		    shift
		    i=0
		    while [ $i -lt "$count" ]; do
			while read -r line; do
			    (($(mpc sticker "$line" get "skipcount" 2>/dev/null)))
			    skipcount=${skipcount:-0}
			    skiplimit=$(read_config "skip")
			    [[ $skipcount -ge $skiplimit ]] && continue
			    [[ $(__is_in_history "$line") == 0 ||
				$(__is_in_playlist "$line") == 0 ]] ||
			    {
				echo "$line"
				((i++))
			    }
			done <<< "$(search_tag "$@" | shuf -n 1)"
		    done
		fi
		;;
      esac
    else
	echo "usage: getrnd <number> [song|album] <tag> <value>"

    fi
}

__icchk() {
    # check if an internet connection is up and running.
    for interface in /sys/class/net/[\!lo]*; do
	if [[ "$(cat "$interface/carrier")" == 1 ]]; then
	    return 0
	else
	    return 1
	fi
    done
}

__getsima() {
    [[ -a $SIMA ]] && rm $SIMA
    wget -q \
	"http://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=$1&api_key=744b5c9d5eae3289a03548b59bfe137a&format=json" \
	--output-document="$TMPSIMA"
    jq '.. | objects | .name // empty' $TMPSIMA | sed 's/\"//g' > $SIMA
    rm $TMPSIMA
}

getsima() {
    # get songs for a list of similar artists.
    # if no songs are found, pick a random one.
    logme "GETSIMA: getsima called for $1."
    if ! __icchk; then
	echo "mpcw: no internet connection!"
	echo "mpcw: SIMA mode needs access to the internet..."
	return 1
    fi
    __getsima "$1"
    [[ -s  $SIMA ]] && {
	local n=0
    	declare -a data
	while read -r line; do
	    data+=("$line")
	done < "$SIMA"
	for artist in "${data[@]}"; do
	    while :; do
		song="$(find_tag artist "$artist" | shuf -n 1)"
		if [[ -n "$song" ]]; then
		    if ! [[ $(__is_in_history "$song") == 0 &&
			$(__is_in_playlist "$song") == 1 ]]; then
		    
			echo "$song"
			((n++))
			break
		    else
			break
		    fi
		else
		    break
		fi
	    done
        done
	unset data
	rm $SIMA
	[[ $n -gt 0 ]] && {
	    logme "GETSIMA: found $n songs."
            return
	}
    }
    mpc listall | shuf -n 1
    logme "GETSIMA: no song were found."
}

musicnonstop() {
    # enable non-stop mode 
    case "$1" in
      "album") NONSTOP="album"; write_config;;
      "song") NONSTOP="song"; write_config;;
      "sima") NONSTOP="sima"; write_config;;
      "off") NONSTOP="off"; write_config; rpg auto;;
      "help") echo "usage: musicnonstop [album|song] <tag value...tag value>"; return ;;
      *) echo "music non-stop: $(read_config nonstop) | filter: $(read_config filter)"; return
    esac
    shift
    if [ "$*" ]; then
        NONSTOP_FILTER="$*"
	write_config
    else
	NONSTOP_FILTER="off"
	write_config
    fi
    echo "music non-stop: $(read_config nonstop) | filter: $(read_config filter)"
}

pls() {
    local pos
    local fmt
    local PLAYLIST
    local cols
    cols=$(tput cols)
    local PLAYLIST=~/.config/mpcw/playlist
    pos="$(mpc current -f "%position%")"
    fmt="%artist% \ %title% \ %album%"
    mpc playlist -f "$fmt" | awk '{print NR "\\" $0}' | sed "s/^$pos\\\/[>\\\/" > $PLAYLIST

    column \
        -d -N "pos,artist,title,album" \
	-T "artist,title,album" \
	-c "$cols" \
	-t -s "\\" -o "| " $PLAYLIST | less -F
    rm $PLAYLIST 2>/dev/null
}

hist() {
    tac "$MPCW_HIST" | less -F
}

handle_playlist() {
    # handle playlist in non-stop mode
    local mode
    mode="$(read_config nonstop)"
    if [[ "$mode" != "off" ]] && [[ -z "$(getnext file)" || -z "$(pls)" ]]; then
        case "$mode" in
            "album")
		getrnd 1 album $(read_config filter) | mpc -q add 2>/dev/null
		mpc replaygain album
		mpc -q crossfade 0
		mpc -q consume on
		mpc -q random off
		;;
	    "song")
		getrnd 10 song $(read_config filter) | mpc -q add 2>/dev/null
		mpc -q ls mnsr/jingles | shuf -n 1 | mpc -q add 2>/dev/null
		mpc replaygain track;
		mpc -q crossfade 10
		mpc -q consume on
		mpc -q random on
		VOICE="on"; write_config
		;;
	    "sima")
		# SIMilar Artist mode:
		# If playlist is empty, add a random song, play it and
		# add songs for similar artists.
		# if only one song left in the playlist, add a random track
		# then add similar artists for this particular track.
		[[ -z "$(pls)" ]] && {
		    logme "SIMA: playlist is empty"
		    getrnd 1 song | mpc -q add 2>/dev/null
		    mpc -q random off
		    mpc -q --wait play
		    sleep 0.0625
		    mpc -q volume "$(read_config volume)"
		    notify-send -u normal "mpcw: started $(getinfo artist) radio."
		    logme "SIMA: added [$(getinfo artist): $(getinfo title)]"
		    sleep 2
		    getsima "$(getinfo artist)" | mpc -q add 2>/dev/null
		}
		if [[ -z "$(getnext file)" ]]; then
		    logme "SIMA: there's no next song"
		    if [[ -a "$MPCW_LOCK" ]]; then
			logme "SIMA: there's a lock!"
			mpc -q --wait play
			sleep 0.0625
			mpc -q volume "$(read_config volume)"
			sleep 2
			getsima "$(getinfo artist)" | mpc -q add 2>/dev/null
			notify-send -u normal "mpcw: started $(getinfo artist) radio."
		    else
			getrnd 1 song | mpc -q add 2>/dev/null
			logme "SIMA: added [$(getnext artist): $(getnext title)]"
			getsima "$(getnext artist)" | mpc -q add 2>/dev/null
			notify-send -u normal "mpcw: coming next: $(getnext artist) radio."
		    fi
		else
		    logme "SIMA: there is a next song, nothing to do."
		fi
		mpc replaygain track;
		mpc -q crossfade 10
		mpc -q consume on
		mpc -q random on
		VOICE="on"; write_config
		;;
	    *) echo "nonstop: err: something's wrong. [$mode]" >&2
        esac
        [[ "$(pstatus)" == "[stopped]" ]] && {
	    local volume
	    volume="$(read_config volume)"
            mpc -q --wait play
	    sleep 0.0625
            mpc -q volume "$volume"
        }
    else
        return 1
    fi
}

rating() {
    local rating
    local song
    rating=0
    (($(mpc sticker "$(getinfo file)" get rating 2>/dev/null)))
    song="$(mpc current -f "%artist% - %title%" | tr '[:upper:]' '[:lower:]')"
    ((r=rating/2))
    if [[ "$1" == "n" ]]; then
	echo "rating=$r"
    elif [[ "$1" == "s" ]]; then
	case $r in
	    0) echo "-----";;
	    1) echo "*----";;
	    2) echo "**---";;
	    3) echo "***--";;
	    4) echo "****-";;
	    5) echo "*****"
	esac
    else
	echo "mpcw: $song ($r)"
    fi
}

unrate() {
    mpc sticker "$(getinfo file)" delete rating 2>/dev/null
}

love() {
    mpc sticker "$(getinfo file)" set rating 10
    rating
}

like() {
    mpc sticker "$(getinfo file)" set rating 8
    rating
} 

tsok() {
    mpc sticker "$(getinfo file)" set rating 6
    rating
}

soso() {
    mpc sticker "$(getinfo file)" set rating 4
    rating
}

nope() {
    mpc sticker "$(getinfo file)" set rating 2
    rating
}

update_stats() {
    [[ -z "$1" ]] && return
    local playcount
    mpc sticker "$1" set "lastplayed" "$(now)" 2>/dev/null
    (($(playcount)))
    ((playcount+=1))
    mpc sticker "$1" set "playcount" "$playcount" 2>/dev/null
}

reset_stats() {
    [[ -z "$1" ]] && return
    mpc sticker "$1" delete "lastplayed" 2>/dev/null
    mpc sticker "$1" delete "playcount" 2>/dev/null
    mpc sticker "$1" delete "skipcount" 2>/dev/null
    echo "$1 stats resetted."
}

today() {
    date '+%Y-%m-%d'
}

now() {
    date '+%Y-%m-%d %H:%M:%S'
}

__fadein() {
	local V=0
	local volume
       	volume=$(read_config volume)
	mpc -q --wait toggle
	mpc -q volume 0
	while [ "$V" -le "$volume" ]; do
	  mpc -q volume "$V"
	  ((V+=10))
	  sleep 0.0625
	done
}
__fadeout() {
    local volume
    volume="$(status volume)"
    [[ "$volume" == "n/a" ]] && return
    while [ "$volume" -ge 0 ]; do
        mpc -q volume "$volume"
        ((volume-=10))
        sleep 0.0625
    done
    case "$1" in
        "pause") mpc -q pause ;;
        "stop") mpc -q stop ;;
        *) mpc -q pause
    esac
}

status() {
    if [[ -n "$1" ]]; then
        case "$1" in
	    "current") mpc current -f "%artist%: %title%"; return;;
            "volume") mpc volume | sed '{s/volume://;s/%//;s/ //}'; return;;
	    "repeat") arg="\$4";;
	    "random") arg="\$6" ;;
	    "single") arg="\$8";;
	    "consume") arg="\$10";;
	    "progress") mpc | awk 'NR==2 {print $3}'; return;;
	    "help")
		echo "mpcw: options are"
	       	echo "mpcw: current, volume, repeat, random, single, consume, progress]"
		return
		;;
            *) return
        esac
	local nr
	if [[ "$(pstatus)" == "[stopped]" ]]; then
	    nr=1
	else
	    nr=3
	fi
        mpc | sed 's/:/ /' | awk "NR==$nr {print $arg}"
    else
        echo "$(pstatus icon)" "$(mpc current -f "$MPCW_NTF")"
    fi
}

pstatus() {
    local command
    command=$(mpc | awk 'NR==2 {print $1}')
    command=${command:-"[stopped]"}
    [[ -z "$1" ]] && {
        echo "$command"
        return
    }
    if [[ "$1" == "icon" ]]; then
        case "$command" in 
            "[playing]") icon="[>>";;
            "[paused]") icon="[||";;
	    *) icon="[|]"
        esac
	NONSTOP="$(read_config nonstop)"
	case "$NONSTOP" in
	    "album") icon+="<Z=";;
	    "song") icon+="<Z-"
	esac
    fi
    echo "$icon"
}

VOLUME=$(read_config "volume")
VOLUME=${VOLUME:-100}

NONSTOP=$(read_config "nonstop")
NONSTOP=${NONSTOP:-"off"}

NONSTOP_FILTER=$(read_config "filter")
NONSTOP_FILTER=${NONSTOP_FILTER:-"off"}

CLEAN_FREQ=$(read_config "clean")
CLEAN_FREQ=${CLEAN_FREQ:-"1 month"}

SKIP_LIMIT=$(read_config "skip")
SKIP_LIMIT=${SKIP_LIMIT:-"2"}

VOICE=$(read_config "voice")
VOICE=${VOICE:-on}

if [[ "$*" ]]; then
    "$@"
else
    startd
fi
