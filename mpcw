#! /usr/bin/env bash

###################################
# a wrapper+ for mpc              #
#  _ __ ___  _ __   _____      __ #
# | '_ ` _ \| '_ \ / __\ \ /\ / / #
# | | | | | | |_) | (__ \ V  V /  #
# |_| |_| |_| .__/ \___| \_/\_/   #
#           |_| version 0.2       #
###################################

# ALIASES

alias add="mpc add"
alias new="mpc -q stop; mpc -q clear; mpc -q add"
alias list="mpc ls"
alias ins="mpc insert"
alias del="mpc -q del"
alias clr="mpc -q clear"
alias cr="mpc -q crop"
alias sta="stop_after_current" # stop after current
alias si="mpc -q single"
alias rn="mpc -q random; status random"
alias rp="mpc -q repeat; status repeat"
alias cs="mpc -q consume; status consume"
alias np="status;status progress"
alias rnd="getrnd"
alias nx="mpc -q next"
alias pv="mpc -q prev"
alias mns="musicnonstop"
alias mnsa="musicnonstop album"
alias mnss="musicnonstop song"
alias mnsi="musicnonstop sima"
alias mnso="musicnonstop off"
alias move="mpc -q move"
alias xf="mpc crossfade"
alias xfo="mpc crossfade 0"
alias rpg="mpc replaygain"
alias rpga="mpc replaygain album"
alias rpgt="mpc replaygain track"
alias rpgo="mpc replaygain auto"
alias p="toggle"
alias pl="play"
alias pla="play_album"
alias aa="add_album"
alias nxa="next_album"
alias s="stop"
alias sk="skip"
alias usk="unskip"
alias skl="set_skip_limit"
alias seeal="see_album"
alias seear="see_artist"
alias seek="mpc -q seek"
alias upd="((mpc -q update --wait && notify-send 'MPCW: Update finished') &)"

# VARIABLES

declare -r MPCW_SETTINGS=$HOME/.config/mpcw/mpcw.settings
declare -r MPCW_HIST=$HOME/.config/mpcw/mpcw.hist
declare -r MPCW_LOG=$HOME/.config/mpcw/mpcw.log
declare -r MPCW_SIMA=$HOME/.config/mpcw/mpcw.artists
declare -r STICKER_DB=$HOME/.config/mpd/sticker.sql
declare -r MPCW_LOCK=$HOME/.config/mpcw/mpcw.lock
declare -r MPCW_NTF='
%artist%
%title%
%album%
[%date%]'
declare -r MPCW_FMT='artist %artist%\ntitle %title%\nalbum %album%\ndate %date%'

#

logme() {
    echo "$(now) --- $*" >> "$MPCW_LOG"
}

reads() {
    # read settings file.
    # create it with default values if it doesn't exist.
    if ! [[ -a "$MPCW_SETTINGS" ]]; then
	local settings
	settings="volume 100
nonstop off
filter off
clean 1 month
skip 2
voice off
single off"
	mkdir "$HOME/.config/mpcw" 2>/dev/null
        echo "$settings" > "$MPCW_SETTINGS"
    fi
    local result
    result="$(sed -n "s/$1 //p" "$MPCW_SETTINGS")"
    [[ -z "$result" ]] && return 1
    echo "$result"
}

writes() {
    # write setting to file.
    [[ -n "$*" && -n "$2" ]] && {
	local opt="$1"
        shift
        local val="$*"
	sed -i "s/^$opt\s[a-zA-Z0-9].*/$opt $val/" "$MPCW_SETTINGS"
    } || return 1
}

media_update() {
        {
	    echo "status" "$(pstatus)"
            mpc current -f "$MPCW_FMT"
        } > "$HOME/.config/currentmedia"

        killall -s HUP "mpcwt" 2>/dev/null
}

__say() {
    # say current artist and title.
    [[ $(reads voice) == "off" ]] && return
    [[ $(pstatus) != "[playing]" ]] && return
    [[ $(getinfo album) == "MNSR Jingles" ]] && return
    local TMPWAV=$HOME/.config/mpcw/saytmp.wav
    local radio
    case "$(reads nonstop)" in
	"song") radio="MUSIC NON STOP RADIO";;
	"sima") radio="SIMA RADIO";;
    esac
    [[ -n "$radio" ]] && {
	(! type espeak >/dev/null) || {
	    local artist
	    artist="$(getinfo artist)"
	    local title
	    title="$(getinfo title)"
	    local msg
	    msg="...You are listening to: $artist, $title... On $radio."
	    espeak -v en+f4 -w "$TMPWAV" -s 140 2>/dev/null <<< echo "$msg"
	    if [[ "$title" == "$(getinfo title)" && $(pstatus) == "[playing]" ]]; then
		local volume
		volume=$(reads volume)
		local new_vol=$((volume-volume*30/100))
		mpc -q volume  "$new_vol"
		mpv --no-terminal --volume "$volume" "$TMPWAV"
		mpc -q volume "$volume"
		rm "$TMPWAV"
	    fi
	}
    }
}

__clean() {
    local freq
    freq="$(reads clean)"
    local date
    date=$(date -d "now -$freq" "+%Y-%m-%d")
    cp "$MPCW_HIST" "$MPCW_HIST.backup"
    awk '$1 > "'"$date"'"' "$MPCW_HIST" > "$MPCW_HIST.tmp"
    if [[ -n $(diff "$MPCW_HIST" "$MPCW_HIST.tmp") ]]; then
	 logme "cleaned history until $date."
	 rm "$MPCW_HIST"
	 mv "$MPCW_HIST.tmp" "$MPCW_HIST"
    else
	rm "$MPCW_HIST.tmp"
    fi

}

clean_freq() {
    local error
    if [ "$*" ]; then
	local arg1
	local arg2
	if [[ "$1" =~ ^[0-9]+$ ]]; then
	    arg1="$1"
	    if [[ "$2" =~ ^day[s]\?$\|^week[s]\?$\|^month[s]\?$\|^year[s]\?$ ]]; then
		arg2="$2"
	    else
		error=1
	    fi
	else
	    error=1
	fi
    else
	error=1
    fi
    if [[ "$error" == 1 ]]; then
	echo "usage: clean_freq <num [day(s)|week(s)|month(s)|year(s)>"
    else
	writes clean "$arg1" "$arg2"
    fi
}

toggle() {
    if [[ "$(pstatus)" == "[stopped]" ]]; then
	play "$@"
    else
	pause
    fi
}

pause() {
    if [[ "$(pstatus)" == "[playing]" ]]; then
	mpc -q pause
	logme "[PAUSED]"
    else
        play
    fi
}

play() {
    echo > "$MPCW_LOCK"
    local volume
    local nonstop
    volume="$(reads volume)"
    nonstop="$(reads nonstop)"
    logme "[PLAYING] mode::$nonstop; volume::$volume; items::$(mpc playlist | wc -l)"
    if [[ "$(pstatus)" == "[stopped]" ]] && [[ $nonstop != "off" ]]; then
        if ! handle_playlist; then
            mpc -q --wait play "$@"
	    sleep 0.1
	    mpc -q volume "$volume"
	fi
    elif [[ $nonstop == "off" ]]; then
	mpc -q random off
	mpc -q crossfade 0
	mpc -q replaygain auto
	writes voice off
        mpc -q --wait play "$@"
	sleep 0.1
	mpc -q volume "$volume"
    else
        mpc -q --wait play "$@"
	sleep 0.1
	mpc -q volume "$volume"
    fi
    rm "$MPCW_LOCK" 2>/dev/null
}

play_album() {
    # play current song's album
    # if first track of the said album is playing, don't stop
    if [[ $(pstatus) == "[playing]" ]]; then
        album="$(getinfo file)"
        album="${album%/*}"
	[[ "$(mpc ls "$album" | wc -l)" == 1 ]] && return
        mpc -q random off
        mpc -q crossfade 0
	mpc -q replaygain album
        if [[ "$(getinfo track)" == 1 ]]; then
            mpc -q crop
            mpc add "$album"
            mpc -q del 2
        else
            mpc -q clear
	    mpc -q add "$album"
	    mpc -q play 1
        fi
	mpc -q replaygain album
	writes voice off
	echo "MPCW: now playing album: $(mpc current -f "%artist% - %album%")"
    else
        echo "MPCW: not playing."
    fi
}

add_album() {
    # add current song's album.
    if [[ $(pstatus) == "[playing]" ]]; then
	album="$(getinfo file)"
	album="${album%/*}"
	[[ "$(mpc ls "$album" | wc -l)" == 1 ]] && return
	mpc -q random off
	mpc -q crossfade 0
	mpc -q replaygain album
	mpc -q crop
	mpc -q add "$album"
	[[ "$(getinfo track)" == 1 ]] && mpc -q del 2
	echo "MPCW: added album: $(mpc current -f "%artist% - %album%")"
	writes voice off
    fi
}

see_album() {
    # display current song's album.
    if [[ $(pstatus) != "[stopped]" ]]; then
        album="$(getinfo file)"
	album="${album%/*}"
	mpc ls "$album" | less -F
   fi
}

see_artist() {
    # display current artist's albums.
    if [[ $(pstatus) != "[stopped]" ]]; then
        artist="$(getinfo file)"
	artist="${artist%%/*}"
	mpc ls "$artist" | less -F
    fi
}

next_album() {
    if [[ $(pstatus) == "[playing]" &&
	$(reads nonstop) == "album" ]]; then
        mpc -q stop
	mpc -q clear
    else
	echo "MPCW: not in album mode!"
    fi
}

__is_in_history() {
    grep -q "$1" "$MPCW_HIST" 2>/dev/null
    echo $?
}

__is_in_playlist() {
    mpc playlist -f "%file%" > "current"
    grep -q "$1" "current" 2>/dev/null
    echo $?
    rm "current" 2>/dev/null
}

search() {
    if [ "$*" ]; then
        command="mpc search"
        for ARG in "$@"; do
            command="$command any $ARG"
        done
	eval "$command"
    fi
}

search_tag() {
    local error
    if [ "$*" ]; then
        if ! ( mpc search "$@" 2>/dev/null ); then
	    error=1
	else
	    error=0
	fi
    else
	error=1
    fi
    [[ "$error" -eq 1 ]] &&
    (
	echo "MPCW: <$*> did not return any result!"
	echo "usage: search_tag <tag value ... tag value>"
	return 1
    )
}

find_tag() {
    local error
    if [ "$*" ]; then
	if ! (mpc find "$@" 2>/dev/null); then
	    error=1
	else
	    error=0
	fi
    else
	error=1
    fi
    [[ "$error" -eq 1 ]] && {
	echo "MPCW: <$*> did not return any result!"
	echo "usage: search_tag <tag value ... tag value>"
	return 1
    }
}
   
__search() {
    echo "select uri from sticker where name=\"$1\" and value $2 $3;"
    sqlite3 "$STICKER_DB" "select uri from sticker where name=\"$1\" and value $2 $3;"
}

skipcount() {
    local skipcount
    skipcount=$(mpc sticker "$(getinfo file)" get "skipcount" 2>/dev/null)
    echo "${skipcount:-"skipcount=0"}"
}

playcount() {
    local playcount
    local song
    song="$(mpc current -f "%artist% - %title%" | tr '[:upper:]' '[:lower:]')"
    playcount="$(mpc sticker "$(getinfo file)" get "playcount" 2>/dev/null)"
    echo "${playcount:-playcount=0}"
}

lastplayed() {
    lastplayed=$(mpc sticker "$(getinfo file)" get "lastplayed" 2>/dev/null)
    [[ -n $lastplayed ]] && echo "$lastplayed"
}

skip() {
    local skipcount
    (($(skipcount)))
    ((skipcount+=1))
    mpc sticker "$1" set "lastplayed" "$(now)" 2>/dev/null
    mpc sticker "$(getinfo file)" set "skipcount" "$skipcount" 2>/dev/null
    mpc -q next
}

unskip() {
    local song
    if [[ -z "$1" ]]; then
	song="$(getinfo file)"
    else
	song="$1"
    fi
    mpc sticker "$song" set "skipcount" 0 2>/dev/null
}

set_skip_limit() {
    if [[ $1 =~ ^[0-9]+$ ]]; then
	writes skip "$1"
    else
	echo "MPCW: skip_limit=$(reads skip)"
    fi
}

stop() {
    echo > "$MPCW_LOCK"
    mpc -q stop
    logme "[STOPPED]"
    rm "$MPCW_LOCK"
}

stop_after_current() {
    mpc -q single
    writes single "$(status single)"
}

vol() {
    local notify=1
    if [[ "$1" == "-n" ]]; then
	notify=0
	shift
    fi
    if [ -z "$1" ]; then
	reads volume
    elif [[ "$(pstatus)" != "[stopped]" ]]; then
	mpc -q volume "$1"
	writes volume "$(status volume)"
    elif [[ "$1" =~ ^[\+\|\-] ]]; then
	    local volume
	    volume="$(reads volume)"
	    ((volume+=$1))
	    [[ "$volume" -gt 100 ]] && volume=100
	    [[ "$volume" -lt 0 ]] && volume=0
	    writes volume "$volume"
    else
	writes volume "$1"
    fi
    [[ "$notify" == 0 ]] &&
	notify-send -u normal -t 1000 "MPCW: Volume $(reads volume)%" 
}

dim() {
    # -6dB dimmer.
    [[ $(pstatus) == "[stopped]" || $(pstatus) == "[paused]" ]] &&
	{
	    echo "MPCW: not playing"
    	    return
	}
    local current_volume
    local saved_volume
    current_volume="$(status volume)"
    saved_volume="$(reads volume)"
    if [[ $current_volume -lt $saved_volume ]]; then
	mpc -q volume "$saved_volume"
	if [[ -z "$1" ]]; then
	    echo "MPCW: dim off."
	elif [[ "$1" == "-n" ]]; then
	    notify-send -u normal -t 1000 "MPCW: dim off"
	else
	    echo "MPCW: dim off."
	    echo "usage: dim [-n]"
	fi
    elif [[ $current_volume -eq $saved_volume ]]; then
	((current_volume/=2))
	mpc -q volume $current_volume
	if [[ -z "$1" ]]; then
	    echo "MPCW: dim on"
	elif [[ "$1" == "-n" ]]; then
	    notify-send -u normal -t 1000 "MPCW: dim on"
	else
	    echo "MPCW: dim on."
	    echo "usage: dim [-n]"
	fi
   fi
}

getinfo() {
    if [ "$1" ]; then
	local info
	info=$(mpc current -f "%$1%")
	[[ "$info" == "%*" ]] && return 1
	echo "$info"
    else
	return 1
    fi
}

getnext() {
    local command
    command=$(mpc queued -f "%$1%")
    [[ $command == "%"* ]] || echo "$command"
}

getrnd() {
    # get random songs / albums
    if [[ $1 =~ ^[0-9]+$ ]]; then
        local count
	count=$1
	shift
        case "$1" in
            "album")
                if [[ "$2" == "off" ]] || [[ -z "$2" ]]; then
                    mpc listall 2>/dev/null | shuf -n "$count" | sed 's/\/[0-9]+*.*//'
		else
		    shift
		    search_tag "$@" | shuf -n "$count" | sed 's/\/[0-9]+*.*//'
		fi
	        ;;
	    "song")
		if [[ "$2" == "off" ]] || [[ -z "$2" ]]; then
		    i=0
		    while [ $i -lt "$count" ]; do
			while read -r line; do
			    (($(mpc sticker "$line" get "skipcount" 2>/dev/null)))
			    skc=${skipcount:-0}
			    skl=$(reads "skip")
			    [[ $skc -ge $skl ]] && continue
			    [[ $(__is_in_history "$line") == 0 ||
				$(__is_in_playlist "$line") == 0 ]] ||
			    { 
				echo "$line"
				((i++))
			    }
			done <<< "$(mpc listall | shuf -n 1)"
		    done
		else
		    shift
		    i=0
		    while [ $i -lt "$count" ]; do
			while read -r line; do
			    (($(mpc sticker "$line" get "skipcount" 2>/dev/null)))
			    skc=${skipcount:-0}
			    skl=$(reads "skip")
			    [[ $skc -ge $skl ]] && continue
			    [[ $(__is_in_history "$line") == 0 ||
				$(__is_in_playlist "$line") == 0 ]] ||
			    {
				echo "$line"
				((i++))
			    }
			done <<< "$(search_tag "$@" | shuf -n 1)"
		    done
		fi
		;;
      esac
    else
	echo "usage: getrnd <number> [song|album] <tag> <value>"

    fi
}

__icchk() {
    # check if an internet connection is up and running.
    for interface in /sys/class/net/[\!lo]*; do
	if [[ "$(cat "$interface/carrier")" == 1 ]]; then
	    return 0
	else
	    return 1
	fi
    done
}

__getsima() {
    #TODO: Save artists
    [[ -a "$MPCW_SIMA" ]] && rm "$MPCW_SIMA"
    wget -q \
	"http://ws.audioscrobbler.com/2.0/?method=artist.getsimilar&artist=$1&api_key=744b5c9d5eae3289a03548b59bfe137a&format=json" \
	--output-document="/tmp/artists.tmp"
    jq '.. | objects | .name // empty' "/tmp/artists.tmp" | sed 's/\"//g' > "$MPCW_SIMA"
    rm "/tmp/artists.tmp"
}

getsima() {
    # get songs for a list of similar artists.
    # if no songs are found, pick a random one.
    logme "GETSIMA: getsima called for $1."
    if ! __icchk; then
	echo "MPCW: no internet connection!"
	echo "MPCW: SIMA mode needs access to the internet..."
	logme "GETSIMA: no internet!"
	return 1
    fi
    __getsima "$1"
    [[ -s  "$MPCW_SIMA" ]] && {
	local n=0
    	declare -a data
	while read -r line; do
	    data+=("$line")
	done < "$MPCW_SIMA"
	for artist in "${data[@]}"; do
	    while :; do
		song="$(find_tag artist "$artist" | shuf -n 1)"
		if [[ -n "$song" ]]; then
		    if ! [[ $(__is_in_history "$song") == 0 &&
			$(__is_in_playlist "$song") == 1 ]]; then
			echo "$song"
			((n++))
			break
		    else
			break
		    fi
		else
		    break
		fi
	    done
        done
	unset data
	rm "$MPCW_SIMA"
	[[ $n -gt 0 ]] && {
	    logme "GETSIMA: found $n songs."
            return
	}
    }
#    mpc listall | shuf -n 1
    logme "GETSIMA: no song were found."
}

musicnonstop() {
    # enable non-stop mode 
    case "$1" in
	album) writes nonstop album;;
	song) writes nonstop song;;
	sima) writes nonstop sima;;
	off) writes nonstop off;;
	help) echo "usage: musicnonstop [album|song|sima] <tag value...tag value>"; return ;;
	*) echo "music non-stop: $(reads nonstop) | filter: $(reads filter)"; return
    esac
    shift
    if [ "$*" ]; then
	if [[ "$(reads nonstop)" == "sima" ]]; then
	    echo "music non-stop: no filter allowed in sima mode."
	    echo "music non-stop: setting to <off>."
	    writes filter off
	else
	    writes filter "$*"
	fi
    else
	writes filter off
    fi
    echo "music non-stop: $(reads nonstop) | filter: $(reads filter)"
}

pls() {
    local pos
    local fmt
    local PLAYLIST
    local cols
    cols=$(tput cols)
    local PLAYLIST=$HOME/.config/mpcw/playlist
    pos="$(mpc current -f "%position%")"
    fmt="%artist% \ %title% \ %album%"
    mpc playlist -f "$fmt" | awk '{print NR "\\" $0}' | sed "s/^$pos\\\/[>\\\/" > "$PLAYLIST"

    column \
        -d -N "pos,artist,title,album" \
	-T "artist,title,album" \
	-c "$cols" \
	-t -s "\\" -o "| " "$PLAYLIST" | less -F
    rm "$PLAYLIST" 2>/dev/null
}

hist() {
    tac "$MPCW_HIST" | less -F
}

handle_playlist() {
    # handle playlist in non-stop mode
    local mode
    mode="$(reads nonstop)"
    if [[ "$mode" != "off" ]] && [[ -z "$(getnext file)" || -z "$(pls)" ]]; then
	[[ "$(mpc playlist | wc -l)" -gt 1 ]] && return 1
	logme "[H] mode::$mode; items::$(mpc playlist | wc -l)"
        case "$mode" in
            "album")
		local filter
		if [[ "${SHELL##*/}" == "zsh" ]]; then
		    #shellcheck disable=SC2207
		    filter=( $(reads filter) )
		else
		    read -ra filter <<< "$(reads filter)"
		fi
		getrnd 1 album "${filter[@]}" | mpc -q add 2>/dev/null
		mpc replaygain album
		mpc -q crossfade 0
		mpc -q consume on
		mpc -q random off
		writes voice off
		logme "[H] added new album."
		;;
	    "song")
		local filter
		if [[ "${SHELL##*/}" == "zsh" ]]; then
		    #shellcheck disable=SC2207
		    filter=( $(reads filter) )
		else
		    read -ra filter <<< "$(reads filter)"
		fi
		getrnd 10 song "${filter[@]}" | mpc -q add 2>/dev/null
		mpc -q ls mnsr/jingles | shuf -n 1 | mpc -q add 2>/dev/null
		mpc replaygain track;
		mpc -q crossfade 10
		mpc -q consume on
		mpc -q random on
		writes voice on
		logme "[H] added new songs."
		;;
	    "sima")
		# SIMilar Artist mode:
		# If playlist is empty, add a random song, play it and
		# add songs for similar artists.
		# if only one song left in the playlist, add a random track
		# then add similar artists for this particular track.
		[[ -z "$(pls)" ]] && {
		    logme "SIMA: playlist is empty"
		    getrnd 1 song | mpc -q add 2>/dev/null
		    mpc -q random off
		    mpc -q --wait play
		    sleep 0.1
		    mpc -q volume "$(reads volume)"
		    notify-send -u normal $'MPCW:\n'"$(getinfo artist)"' radio.'
		    logme "[H/SIMA]: added [$(getinfo artist): $(getinfo title)]"
		    sleep 2
		    getsima "$(getinfo artist)" | mpc -q add 2>/dev/null
		}
		if [[ -z "$(getnext file)" ]]; then
		    logme "[H/SIMA]: there's no next song"
		    if [[ -a "$MPCW_LOCK" ]]; then
			logme "[H/SIMA]: there's a lock!"
			mpc -q --wait play
			sleep 0.1
			mpc -q volume "$(reads volume)"
			sleep 2
			getsima "$(getinfo artist)" | mpc -q add 2>/dev/null
			notify-send -u normal $'MPCW:\n'"$(getinfo artist)"' radio.'
		    else
			getrnd 1 song | mpc -q add 2>/dev/null
			logme "[H/SIMA]: added [$(getnext artist): $(getnext title)]"
			getsima "$(getnext artist)" | mpc -q add 2>/dev/null
			notify-send -u normal $'MPCW: Coming next:\n'"$(getnext artist)"' radio.'
		    fi
		else
		    logme "[H/SIMA]: there is a next song, nothing to do."
		fi
		mpc replaygain track;
		mpc -q crossfade 10
		mpc -q consume on
		mpc -q random on
		writes voice on
		;;
	    *) echo "nonstop: err: something's wrong. [$mode]" >&2
        esac
        [[ "$(pstatus)" == "[stopped]" ]] && {
	    local volume
	    volume="$(reads volume)"
            mpc -q --wait play
	    sleep 0.1
            mpc -q volume "$volume"
        }
    else
        return 1
    fi
}

#shellcheck disable=SC2120
rating() {
    local rating
    local song
    rating=0
    (($(mpc sticker "$(getinfo file)" get rating 2>/dev/null)))
    song="$(mpc current -f "%artist% - %title%" | tr '[:upper:]' '[:lower:]')"
    ((r=rating/2))
    if [[ "$1" == "n" ]]; then
	echo "rating=$r"
    elif [[ "$1" == "s" ]]; then
	case $r in
	    0) echo "-----";;
	    1) echo "*----";;
	    2) echo "**---";;
	    3) echo "***--";;
	    4) echo "****-";;
	    5) echo "*****"
	esac
    else
	echo "MPCW: $song ($r)"
    fi
}

unrate() {
    mpc sticker "$(getinfo file)" delete rating 2>/dev/null
}

love() {
    mpc sticker "$(getinfo file)" set rating 10
    rating
}

like() {
    mpc sticker "$(getinfo file)" set rating 8
    rating
} 

tsok() {
    mpc sticker "$(getinfo file)" set rating 6
    rating
}

soso() {
    mpc sticker "$(getinfo file)" set rating 4
    rating
}

nope() {
    mpc sticker "$(getinfo file)" set rating 2
    rating
}

update_stats() {
    [[ -z "$1" ]] && return
    local playcount
    mpc sticker "$1" set "lastplayed" "$(now)" 2>/dev/null
    (($(playcount)))
    ((playcount+=1))
    mpc sticker "$1" set "playcount" "$playcount" 2>/dev/null
}

reset_stats() {
    [[ -z "$1" ]] && return
    mpc sticker "$1" delete "lastplayed" 2>/dev/null
    mpc sticker "$1" delete "playcount" 2>/dev/null
    mpc sticker "$1" delete "skipcount" 2>/dev/null
    echo "$1 stats resetted."
}

today() {
    date '+%Y-%m-%d'
}

now() {
    date '+%Y-%m-%d %H:%M:%S'
}

status() {
    if [[ -n "$1" ]]; then
        case "$1" in
	    "current") mpc current -f "%artist%: %title%"; return;;
            "volume") mpc volume | sed '{s/volume://;s/%//;s/ //}'; return;;
	    "repeat") arg="\$4";;
	    "random") arg="\$6" ;;
	    "single") arg="\$8";;
	    "consume") arg="\$10";;
	    "progress") mpc | awk 'NR==2 {print $3}'; return;;
	    "help")
		echo "MPCW: options are"
	       	echo "MPCW: current, volume, repeat, random, single, consume, progress."
		return
		;;
            *) return
        esac
	local nr
	if [[ "$(pstatus)" == "[stopped]" ]]; then
	    nr=1
	else
	    nr=3
	fi
        mpc | sed 's/:/ /' | awk "NR==$nr {print $arg}"
    else
        echo "$(pstatus icon)" "$(mpc current -f "$MPCW_NTF")"
    fi
}

pstatus() {
    local player_status
    player_status=$(mpc | awk 'NR==2 {print $1}')
    player_status=${player_status:-"[stopped]"}
    [[ -z "$1" ]] && {
        echo "$player_status"
        return
    }
    if [[ "$1" == "icon" ]]; then
        case "$player_status" in 
            "[playing]") icon="[>>";;
            "[paused]") icon="[||";;
	    "[stopped]") icon="[|]"
        esac
	NONSTOP="$(reads nonstop)"
	case "$NONSTOP" in
	    "album") icon+=" (=)";;
	    "song") icon+=" (-)";;
	    "sima") icon+=" (s)"
	esac
    fi
    echo "$icon"
}

if [[ "$*" ]]; then
    "${@:-}"
fi
